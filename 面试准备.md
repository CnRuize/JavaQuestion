1. Java基础
   1. Java三大特性
      1. 封装
      2. 继承
      3. 多态
   2. 反射 
   3. String，StringBuilder，StringBuffer的区别？
      1. String：不可变的字符序列，线程安全，效率高，适用于少量字符串的场景。
      2. StringBuilder：可变的字符序列，线程不安全，效率高，适用于单线程场景。
      3. StringBuffer：可变的字符序列，线程安全，效率低，适用于多线程场景。
         1. 内部使用了 synchronized 关键字，效率低。
   4. 序列化
2. 集合
   1. ArrayList的扩容机制
      1. 如果是初始大小为空，设定初始大小为0，在第一次写入数据的时候会进行扩容到10；如果设定初始为0，那么就执行正常的扩容；当数组没有容量的时候才会扩容，新数组的长度是旧数组1.5倍，（底层代码是new_length = length + length >> 1）先创建新的数组，然后执行复制操作，最后销毁旧的数组，整个扩容完成
   2. HashMap相关
      1. HashMap的底层数据结构是什么？
         1. 数组+链表+红黑树的结构
      2. HashMap的扩容机制以及树化机制？
         1.  扩容机制：HashMap的默认容量是16，扩容因子是0.75，当实际存储的节点数大于等于0.75 * 16时，就会触发扩容，桶的数量会变成两倍。
         2.  树化机制：当一个桶内的键值对达到 8 条之后并且当前桶的数量已经到了 64（历经两次扩容），此时桶内的数据才会由链表的形式转变为红黑树的形式。如果桶内的键值对小于 6，则会重新变成链表结构。
      3. 重写equals方法要不要重写hashcode方法？
         1. 必须要重写hashcode方法。在默认情况下equals方法返回的内容是内存地址的文本，hashCode方法返回的是基于内存地址计算出的整数。如果不重写hashcode方法，就会出现两个对象相同，但是hashCode却不同，导致HashMap的put方法无法将两个对象存入同一个桶内。比如新建两个人对象，一个是23岁的John，另一个是25岁的John，重写equals方法，仅仅比较名称，此时两个人是一样的，但是hashcode是不一样的，与期望相悖。
      4. HashMap的线程安全问题？
         1. HashMap是线程不安全的，数据的更改过程均没有采用CAS+Synchorinzed机制，导致数据不一致。
      5. 如何决定数据存入哪一个桶？
         1. 最终计算出的哈希值对当前桶的数量取余，余数是几就放在哪一个桶内，桶的编号从0开始。
      6. 哈希运算是什么样子的？
         1. 不同的类哈希运算不同，以String为例，首先将初始哈希值右移16位，然后与默认的哈希值进行异或(相同为0，不同为1)运算，得到新的哈希值。int hash = h ^ (h >>> 16);  
   3. ConcurrentHashMap相关
      1. 线程安全的原因：
         1. 扩容机制：ConcurrentHashMap使用了CAS和Synchronized锁机制来保证线程安全的。
         2. 读操作是无锁的：节点数据是被Volatile关键字修饰的。
         3. 写操作：添加数据的时候如果桶为空，仅仅使用CAS就可以实现线程安全，不会出现竞争条件。添加数据时如果桶不为空，需要使用Synchronized锁机制，保证线程安全。Synchornized锁会锁住对应的桶链表的第一个节点，保证线程安全。
         4. 删除操作：删除数据时如果桶不为空，需要使用Synchronized锁机制，保证线程安全。Synchornized锁会锁住对应的桶链表的第一个节点，保证线程安全。
      2. 扩容机制：
         1. sizeCtl = 0.75 * capacity; // 当前桶数组容量 * 负载因子，当实际存储的节点数 size >= sizeCtl 时，就会触发扩容；扩容时，将数组扩大为原来的 2 倍。
         2. 设置扩容状态sizeCtl = -1; // 负值表示正在扩容
         3. 多个线程一起迁移数据
         4. 将已经迁移完成的桶设置标记ForwardingNode，并将ForwardingNode的next指针指向新的数组，然后将ForwardingNode置为null，表示迁移完成。
         5. 所有桶迁移完成之后table指向新的数组，sizeCtl = 0，表示扩容完成。
3. 多线程
4. 数据结构
   1. 红黑树的特性
      1. 红黑树结构保证查找性能是O(logn)，插入删除性能是O(logn)，是一种平衡二叉树。
      2. 结构满足5条性质：
         1. 根节点是黑色。
         2. 每个节点是红色或者黑色。
         3. 每个叶子节点（NIL）是黑色。
         4. 如果一个节点是红色，则它的子节点必须是黑色。
         5. 从任一节点到其每个叶子的所有路径上包含相同数目的黑色节点。
5. Spring框架
   1. Spring的控制反转（IoC），面向切面编程（AOP）。
6. 是如何往Excel中写入数据的？
   1. 引入依赖
    ```xml
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>5.2.3</version>
        </dependency>
    ```
   