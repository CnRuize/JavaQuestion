1. 集合
   1. HashMap相关
      1. HashMap的底层数据结构是什么？
         1. 数组+链表+红黑树的结构
      2. HashMap的扩容机制以及树化机制？
         1.  扩容机制：HashMap的默认容量是16，扩容因子是0.75，当实际存储的节点数大于等于0.75 * 16时，就会触发扩容，桶的数量会变成两倍。
         2.  树化机制：当一个桶内的键值对达到 8 条之后并且当前桶的数量已经到了 64（历经两次扩容），此时桶内的数据才会由链表的形式转变为红黑树的形式。如果桶内的键值对小于 6，则会重新变成链表结构。
      3. 重写equals方法要不要重写hashcode方法？
         1. 必须要重写hashcode方法。在默认情况下equals方法返回的内容是内存地址的文本，hashCode方法返回的是基于内存地址计算出的整数。如果不重写hashcode方法，就会出现两个对象相同，但是hashCode却不同，导致HashMap的put方法无法将两个对象存入同一个桶内。比如新建两个人对象，一个是23岁的John，另一个是25岁的John，重写equals方法，仅仅比较名称，此时两个人是一样的，但是hashcode是不一样的，与期望相悖。
   2. ConcurrentHashMap相关
      1. 线程安全的原因：
         1. 扩容机制：ConcurrentHashMap使用了CAS和Synchronized锁机制来保证线程安全的。
         2. 读操作是无锁的：节点数据是被Volatile关键字修饰的。
         3. 写操作：添加数据的时候如果桶为空，仅仅使用CAS就可以实现线程安全，不会出现竞争条件。添加数据时如果桶不为空，需要使用Synchronized锁机制，保证线程安全。Synchornized锁会锁住对应的桶链表的第一个节点，保证线程安全。
         4. 删除操作：删除数据时如果桶不为空，需要使用Synchronized锁机制，保证线程安全。Synchornized锁会锁住对应的桶链表的第一个节点，保证线程安全。
      2. 扩容机制：
         1. sizeCtl = 0.75 * capacity; // 当前桶数组容量 * 负载因子，当实际存储的节点数 size >= sizeCtl 时，就会触发扩容；扩容时，将数组扩大为原来的 2 倍。
         2. 设置扩容状态sizeCtl = -1; // 负值表示正在扩容
         3. 多个线程一起迁移数据
         4. 将已经迁移完成的桶设置标记ForwardingNode，并将ForwardingNode的next指针指向新的数组，然后将ForwardingNode置为null，表示迁移完成。
         5. 所有桶迁移完成之后table指向新的数组，sizeCtl = 0，表示扩容完成。
2. 多线程
3. 数据结构
   1. 红黑树的特性
      1. 红黑树结构保证查找性能是O(logn)，插入删除性能是O(logn)，是一种平衡二叉树。
      2. 结构满足5条性质：
         1. 根节点是黑色。
         2. 每个节点是红色或者黑色。
         3. 每个叶子节点（NIL）是黑色。
         4. 如果一个节点是红色，则它的子节点必须是黑色。
         5. 从任一节点到其每个叶子的所有路径上包含相同数目的黑色节点。
4. 是如何往Excel中写入数据的？
   1. 引入依赖
    ```xml
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>5.2.3</version>
        </dependency>
    ```
   